# Модификаторы используемые не для доступа

Java предоставляет ряд [модификаторов не для доступа](http://proglang.su/java/modifiers#modifikatory-klassa-metoda-peremennoy-i-potoka-ispolzuemye-ne-dlya-dostupa), а для реализации многих других функциональных возможностей:

* модификатор _static_ применяется для создания методов и переменных класса;
* модификатор _final_ используется для завершения реализации классов, методов и переменных;
* модификатор _abstract_ необходим для создания абстрактных классов и методов;
* модификаторы _synchronized_ и _volatile_ используются в Java для потоков.

### Модификатор static <a href="#modifikator-static" id="modifikator-static"></a>

**Модификатор static** — применяется для создания методов и переменных класса.

**Переменные static**

Ключевое слово static используется для создания переменных, которые будут существовать независимо от каких-либо экземпляров, созданных для класса. Только одна копия переменной static в Java существует вне зависимости от количества экземпляров класса.

Статические переменные также известны как переменные класса. В Java локальные переменные не могут быть объявлены статическими (static).

**Методы static**

Ключевое слово static используется для создания методов, которые будут существовать независимо от каких-либо экземпляров, созданных для класса.

В Java статические методы или методы static не используют какие-либо переменные экземпляра любого объекта класса, они определены. Методы static принимают все данные из параметров и что-то из этих параметров вычисляется без ссылки на переменные.

Переменные и методы класса могут быть доступны с использованием имени класса, за которым следует точка и имя переменной или метода.

**Пример**

Модификатор static в Java используется для создания методов классов и переменных, как показано в следующем примере:

```java
public class InstanceCounter {

   private static int numInstances = 0;

   protected static int getCount() {
      return numInstances;
   }

   private static void addInstance() {
      numInstances++;
   }

   InstanceCounter() {
      InstanceCounter.addInstance(); 
   }

   public static void main(String[] arguments) {
      System.out.println("Начиная с " +
      InstanceCounter.getCount() + " экземпляра");
      for (int i = 0; i < 500; ++i){
         new InstanceCounter();
	  }
      System.out.println("Создано " +
      InstanceCounter.getCount() + " экземпляров");
   }
}
```

Будет получен следующий результат:

```
Начиная с 0 экземпляра
Создано 500 экземпляров
```

### Модификатор final <a href="#modifikator-final" id="modifikator-final"></a>

**Модификатор final** — используется для завершения реализации классов, методов и переменных.

**Переменные final**

Переменная final может быть инициализирована только один раз. Ссылочная переменная, объявленная как final, никогда не может быть назначен для обозначения другого объекта.

Однако данные внутри объекта могут быть изменены. Таким образом, состояние объекта может быть изменено, но не ссылки.

С переменными в Java модификатор final часто используется со static, чтобы сделать константой переменную класса.

**Пример**

```java
public class Test{
  final int value = 10;
  // Ниже приведены примеры объявления констант:
  public static final int BOXWIDTH = 6;
  static final String TITLE = "Менеджер";
  
  public void changeValue(){
     value = 12; //будет получена ошибка
  }
}
```

**Методы final**

Метод final не может быть переопределен любым подклассом. Как упоминалось ранее, в Java модификатор final предотвращает метод от изменений в подклассе.

Главным намерение сделать метод final будет то, что содержание метода не должно быть изменено стороне.

**Пример**

Объявление метода, использующего модификатор final в объявление класса, показано в следующем примере:

```java
public class Test{
    public final void changeName(){
       // тело метода
    }
}
```

**Класс final**

Основная цель в Java использования класса объявленного в качестве final заключается в предотвращении класс от быть подклассом. Если класс помечается как final, то ни один класс не может наследовать любую функцию из класса final.

**Пример**

```java
public final class Test {
   // тело класса
}
```

### Модификатор abstract <a href="#modifikator-abstract" id="modifikator-abstract"></a>

**Модификатор abstract** — используется для создания абстрактных классов и методов.

**Класс abstract**

Класс abstract не может создать экземпляр. Если класс объявлен как abstract, то единственная цель для него быть расширенным.

Класс не может быть одновременно abstract и final, так как класс final не может быть расширенным. Если класс содержит абстрактные методы, то он должен быть объявлен как abstract. В противном случае будет сгенерирована ошибка компиляции.

Класс abstract может содержать как абстрактные методы, а также и обычные.

**Пример**

```java
abstract class Caravan{
   private double price;
   private String model;
   private String year;
   public abstract void goFast(); //абстрактный метод
   public abstract void changeColor();
}
```

**Метод abstract**

Метод abstract является методом, объявленным с любой реализацией. Тело метода (реализация) обеспечивается подклассом. Методы abstract никогда не могут быть final или strict.

Любой класс, который расширяет абстрактный класс должен реализовать все абстрактные методы суперкласса, если подкласс не является абстрактным классом.

Если класс в Java содержит один или несколько абстрактных методов, то класс должен быть объявлен как abstract. Абстрактный класс не обязан содержать абстрактные методы.

Абстрактный метод заканчивается точкой с запятой. Пример: public abstract sample();

**Пример**

```java
public abstract class SuperClass{
    abstract void m(); //абстрактный метод
}

class SubClass extends SuperClass{
     // реализует абстрактный метод
      void m(){
	  .........
      }
}
```

### Модификатор synchronized <a href="#modifikator-synchronized" id="modifikator-synchronized"></a>

**Модификатор synchronized** — используются в Java для потоков.

Ключевое слово synchronized используется для указания того, что метод может быть доступен только одним потоком одновременно. В Java модификатор synchronized может быть применен с любым из четырех модификаторов уровня доступа.

**Пример**

```java
public synchronized void showDetails(){
.......
}
```

#### Модификатор transient <a href="#modifikator-transient" id="modifikator-transient"></a>

Переменная экземпляра отмеченная как transient указывает виртуальной машине Java (JVM), чтобы пропустить определённую переменную при сериализации объекта, содержащего её.

Этот модификатор включён в оператор, что создает переменную, предшествующего класса или типа данных переменной.

**Пример**

```java
public transient int limit = 55;   // не будет сохраняться
public int b; // будет сохраняться
```

### Модификатор volatile <a href="#modifikator-volatile" id="modifikator-volatile"></a>

**Модификатор volatile** — используются в Java для потоков.

В Java модификатор volatile используется, чтобы позволить знать JVM, что поток доступа к переменной всегда должен объединять свою собственную копию переменной с главной копией в памяти.

Доступ к переменной volatile синхронизирует все кэшированные скопированные переменные в оперативной памяти. Volatile может быть применен только к переменным экземпляра, которые имеют тип объект или private. Ссылка на объект volatile может быть null.

**Пример**

```java
public class MyRunnable implements Runnable{
    private volatile boolean active;
 
    public void run(){
        active = true;
        while (active){ // линия 1
            // здесь какой-нибудь код
        }
    }
    
    public void stop(){
        active = false; // линия 2
    }
}
```

Как правило, run() вызывается в одном потоке (впервые начинаете использовать Runnable в Java), а stop() вызывается из другого потока. Если в линии 1 используется кэшированное значение active, то цикл не может остановиться, пока Вы не установите active false в линии 2.

В следующем уроке обсудим основные операторы, используемые в языке Java. Этот раздел даст Вам обзор того, как можно использовать их во время разработки приложения.
